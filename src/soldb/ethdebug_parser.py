"""
ETHDebug Parser for EVM Debugging

Parses ethdebug format debug information generated by solc compiler.
"""

import json
import os
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from pathlib import Path


@dataclass
class SourceLocation:
    """Represents a source code location."""
    source_id: int
    offset: int
    length: int
    
    def __repr__(self):
        return f"Source({self.source_id}:{self.offset}+{self.length})"


@dataclass
class Instruction:
    """Represents a single EVM instruction with debug info."""
    offset: int  # Bytecode offset
    operation: Dict[str, Any]  # mnemonic and arguments
    context: Optional[Dict[str, Any]] = None  # Source mapping context
    
    @property
    def mnemonic(self) -> str:
        return self.operation.get('mnemonic', '')
    
    @property
    def arguments(self) -> List[str]:
        return self.operation.get('arguments', [])
    
    @property
    def source_location(self) -> Optional[SourceLocation]:
        if not self.context or 'code' not in self.context:
            return None
        
        code_info = self.context['code']
        if 'source' in code_info and 'range' in code_info:
            return SourceLocation(
                source_id=code_info['source']['id'],
                offset=code_info['range']['offset'],
                length=code_info['range']['length']
            )
        return None


@dataclass
class VariableLocation:
    """Represents a variable's location in stack/memory/storage."""
    name: str
    type: str
    location_type: str  # "stack", "memory", "storage"
    offset: int
    pc_range: Tuple[int, int]  # (start_pc, end_pc)
    
    def is_active_at_pc(self, pc: int) -> bool:
        """Check if this variable is active at the given PC."""
        return self.pc_range[0] <= pc <= self.pc_range[1]


@dataclass
class ETHDebugInfo:
    """Container for ethdebug debugging information."""
    compilation: Dict[str, Any]
    contract_name: str
    environment: str  # 'create' or 'runtime'
    instructions: List[Instruction]
    sources: Dict[int, str]  # source_id -> file path
    variable_locations: Dict[int, List[VariableLocation]] = field(default_factory=dict)  # PC -> variables
    
    def get_instruction_at_pc(self, pc: int) -> Optional[Instruction]:
        """Get instruction at specific program counter."""
        for instruction in self.instructions:
            if instruction.offset == pc:
                return instruction
        return None
    
    def get_source_info(self, pc: int) -> Optional[Tuple[str, int, int]]:
        """Get source file and location for PC."""
        instruction = self.get_instruction_at_pc(pc)
        if not instruction or not instruction.source_location:
            return None
        
        source_loc = instruction.source_location
        source_file = self.sources.get(source_loc.source_id)
        if not source_file:
            return None
        
        return (source_file, source_loc.offset, source_loc.length)
    
    def get_variables_at_pc(self, pc: int) -> List[VariableLocation]:
        """Get all variables active at the given PC."""
        # First check if we have exact PC match
        if pc in self.variable_locations:
            return self.variable_locations[pc]
        
        # Otherwise, find all variables whose range includes this PC
        active_vars = []
        for _, var_list in self.variable_locations.items():
            for var in var_list:
                if var.is_active_at_pc(pc):
                    active_vars.append(var)
        
        return active_vars


class ETHDebugParser:
    """Parser for ethdebug format debug information."""
    
    def __init__(self):
        self.debug_info: Optional[ETHDebugInfo] = None
        self.source_cache: Dict[str, List[str]] = {}
    
    def load_ethdebug_files(self, debug_dir: Union[str, Path], contract_name: Optional[str] = None) -> ETHDebugInfo:
        """Load ethdebug files from a directory."""
        debug_dir = Path(debug_dir)
        # Store debug directory for source file resolution
        self.debug_dir = debug_dir
        
        # Load compilation info
        compilation_file = debug_dir / "ethdebug.json"
        if not compilation_file.exists():
            raise FileNotFoundError(f"ethdebug.json not found in {debug_dir}")
        
        with open(compilation_file) as f:
            compilation_data = json.load(f)
        
        # Build source mapping
        sources = {}
        for source in compilation_data['compilation']['sources']:
            sources[source['id']] = source['path']
        
        debug_file = None
        environment = None

        if contract_name:
            runtime_file = debug_dir / f"{contract_name}_ethdebug-runtime.json"
            create_file = debug_dir / f"{contract_name}_ethdebug.json"
            if runtime_file.exists():
                debug_file = runtime_file
                environment = 'runtime'
            elif create_file.exists():
                debug_file = create_file
                environment = 'create'
            else:
                raise FileNotFoundError(f"No ethdebug file found for contract {contract_name} in {debug_dir}")
        else:
            ethdebug_files = list(debug_dir.glob("*_ethdebug.json"))
            runtime_files = list(debug_dir.glob("*_ethdebug-runtime.json"))
            
            # Use first source path from sources as path
            if sources:
                first_source_path = next(iter(sources.values()))
                contract_name_guess = os.path.splitext(os.path.basename(first_source_path))[0]
                runtime_file = debug_dir / f"{contract_name_guess}_ethdebug-runtime.json"
                create_file = debug_dir / f"{contract_name_guess}_ethdebug.json"
                if runtime_file.exists():
                    debug_file = runtime_file
                    environment = 'runtime'
                elif create_file.exists():
                    debug_file = create_file
                    environment = 'create'
                else:
                    raise FileNotFoundError(f"No ethdebug file found for contract {contract_name_guess} in {debug_dir} (tried {runtime_file.name} i {create_file.name})")
            

        # Extract contract name from filename (for info only)
        contract_name_from_file = debug_file.stem.replace('_ethdebug-runtime', '').replace('_ethdebug', '')

        # Load contract debug info
        with open(debug_file) as f:
            contract_data = json.load(f)
        
        # Parse instructions
        instructions = []
        for inst_data in contract_data.get('instructions', []):
            instruction = Instruction(
                offset=inst_data['offset'],
                operation=inst_data['operation'],
                context=inst_data.get('context')
            )
            instructions.append(instruction)
        
        # Parse variable locations (if available)
        variable_locations = self._parse_variable_locations(contract_data)
        
        self.debug_info = ETHDebugInfo(
            compilation=compilation_data['compilation'],
            contract_name=contract_name_from_file,
            environment=environment,
            instructions=instructions,
            sources=sources,
            variable_locations=variable_locations
        )
        
        return self.debug_info
    
    def _parse_variable_locations(self, contract_data: Dict[str, Any]) -> Dict[int, List[VariableLocation]]:
        """Parse variable location information from ETHDebug data."""
        variable_locations = {}
        
        # Check for variable information in the ETHDebug data
        # The exact format depends on the ETHDebug specification
        # This is a placeholder implementation that can be extended
        # when the full ETHDebug variable format is available
        
        # Look for variable data in instructions
        for inst_data in contract_data.get('instructions', []):
            pc = inst_data['offset']
            context = inst_data.get('context', {})
            
            # Check if this instruction has variable information
            if 'variables' in context:
                var_list = []
                for var_data in context['variables']:
                    var_loc = VariableLocation(
                        name=var_data.get('name', 'unknown'),
                        type=var_data.get('type', 'unknown'),
                        location_type=var_data.get('location', {}).get('type', 'stack'),
                        offset=var_data.get('location', {}).get('offset', 0),
                        pc_range=(
                            var_data.get('scope', {}).get('start', pc),
                            var_data.get('scope', {}).get('end', pc)
                        )
                    )
                    var_list.append(var_loc)
                
                if var_list:
                    variable_locations[pc] = var_list
        
        # Also check for a separate variables section (future ETHDebug format)
        if 'variables' in contract_data:
            for var_data in contract_data['variables']:
                # Parse variable scope and location information
                pc_start = var_data.get('pc_start', 0)
                pc_end = var_data.get('pc_end', 0)
                
                var_loc = VariableLocation(
                    name=var_data.get('name', 'unknown'),
                    type=var_data.get('type', 'unknown'),
                    location_type=var_data.get('location_type', 'stack'),
                    offset=var_data.get('offset', 0),
                    pc_range=(pc_start, pc_end)
                )
                
                # Add to all PCs in range
                for pc in range(pc_start, pc_end + 1):
                    if pc not in variable_locations:
                        variable_locations[pc] = []
                    variable_locations[pc].append(var_loc)
        
        return variable_locations
    
    def load_source_file(self, source_path: str) -> List[str]:
        """Load and cache source file lines."""
        if source_path not in self.source_cache:
            found = False
            
            # Try to find the source file
            if os.path.exists(source_path):
                with open(source_path) as f:
                    self.source_cache[source_path] = f.readlines()
                found = True
            else:
                # If we have debug directory info, try relative to that first
                if hasattr(self, 'debug_dir') and self.debug_dir:
                    debug_relative_path = os.path.join(self.debug_dir, '..', source_path)
                    debug_relative_path = os.path.normpath(debug_relative_path)
                    if os.path.exists(debug_relative_path):
                        with open(debug_relative_path) as f:
                            self.source_cache[source_path] = f.readlines()
                        found = True
                
                if not found:
                    # Try walking up parent directories to find the file
                    filename = os.path.basename(source_path)
                    current_dir = os.getcwd()
                    
                    # Check current directory and up to 3 levels of parent directories
                    for _ in range(4):
                        # Also check subdirectories at each level
                        for root, dirs, files in os.walk(current_dir):
                            if filename in files:
                                full_path = os.path.join(root, filename)
                                with open(full_path) as f:
                                    self.source_cache[source_path] = f.readlines()
                                found = True
                                break
                            # Don't go too deep
                            if root.count(os.sep) - current_dir.count(os.sep) > 2:
                                break
                        
                        if found:
                            break
                        
                        # Move up one directory
                        parent = os.path.dirname(current_dir)
                        if parent == current_dir:  # Reached root
                            break
                        current_dir = parent
                
                if not found:
                    #print(f"Warning: Source file not found: {source_path}")
                    self.source_cache[source_path] = []
        
        return self.source_cache[source_path]
    
    def offset_to_line_col(self, source_path: str, offset: int) -> Tuple[int, int]:
        """Convert byte offset to line and column in source file."""
        lines = self.load_source_file(source_path)
        
        current_offset = 0
        for line_num, line in enumerate(lines, 1):
            line_len = len(line)
            if current_offset + line_len > offset:
                col = offset - current_offset + 1
                return (line_num, col)
            current_offset += line_len
        
        return (1, 1)
    
    def get_source_mapping(self) -> Dict[int, Tuple[str, int, int]]:
        """Get PC to source line mapping."""
        if not self.debug_info:
            return {}
        
        pc_to_source = {}
        
        for instruction in self.debug_info.instructions:
            source_info = self.debug_info.get_source_info(instruction.offset)
            if source_info:
                source_path, offset, length = source_info
                line, col = self.offset_to_line_col(source_path, offset)
                pc_to_source[instruction.offset] = (source_path, line, col)
        
        return pc_to_source
    
    def get_source_context(self, pc: int, context_lines: int = 2) -> Optional[Dict[str, Any]]:
        """Get source code context around a PC."""
        if not self.debug_info:
            return None
        
        source_info = self.debug_info.get_source_info(pc)
        if not source_info:
            return None
        
        source_path, offset, length = source_info
        lines = self.load_source_file(source_path)
        line_num, col = self.offset_to_line_col(source_path, offset)
        
        # Get current line content
        current_content = ""
        if 0 < line_num <= len(lines):
            current_content = lines[line_num - 1].rstrip()
        
        # Get context lines
        start_line = max(1, line_num - context_lines)
        end_line = min(len(lines), line_num + context_lines)
        
        context = {
            'file': source_path,
            'line': line_num,
            'column': col,
            'content': current_content,  # Add the actual line content
            'context_lines': [],  # Changed from 'lines' to 'context_lines'
            'lines': []
        }
        
        # Include context lines for searching
        for i in range(start_line, end_line + 1):
            if i <= len(lines):
                context['context_lines'].append(lines[i-1].rstrip())
                context['lines'].append({
                    'number': i,
                    'content': lines[i-1].rstrip(),
                    'current': i == line_num
                })
        
        return context
    
    def format_instruction_debug(self, pc: int) -> str:
        """Format debug info for an instruction."""
        if not self.debug_info:
            return ""
        
        instruction = self.debug_info.get_instruction_at_pc(pc)
        if not instruction:
            return f"No debug info for PC {pc}"
        
        parts = [f"PC {pc}: {instruction.mnemonic}"]
        
        if instruction.arguments:
            parts.append(f"({', '.join(instruction.arguments)})")
        
        source_info = self.debug_info.get_source_info(pc)
        if source_info:
            source_path, offset, length = source_info
            line, col = self.offset_to_line_col(source_path, offset)
            parts.append(f"@ {os.path.basename(source_path)}:{line}:{col}")
        
        return " ".join(parts)
    
    def get_variables_debug_info(self, pc: int) -> Optional[Dict[str, Any]]:
        """Get variable information at a specific PC."""
        if not self.debug_info:
            return None
        
        variables = self.debug_info.get_variables_at_pc(pc)
        if not variables:
            return None
        
        return {
            'pc': pc,
            'variables': [
                {
                    'name': var.name,
                    'type': var.type,
                    'location': var.location_type,
                    'offset': var.offset
                }
                for var in variables
            ]
        }
    
    def format_variables_debug(self, pc: int, stack: Optional[List[int]] = None, 
                             memory: Optional[bytes] = None, 
                             storage: Optional[Dict[int, int]] = None) -> str:
        """Format variable values for debugging display."""
        var_info = self.get_variables_debug_info(pc)
        if not var_info or not var_info['variables']:
            return ""
        
        lines = ["Local Variables:"]
        for var in var_info['variables']:
            value_str = "?"
            
            # Try to get the actual value based on location
            if var['location'] == 'stack' and stack and var['offset'] < len(stack):
                value_str = hex(stack[var['offset']])
            elif var['location'] == 'memory' and memory:
                # For memory, we'd need to decode based on type
                value_str = "<memory>"
            elif var['location'] == 'storage' and storage and var['offset'] in storage:
                value_str = hex(storage[var['offset']])
            
            lines.append(f"  - {var['name']}: {value_str} ({var['type']}) @ {var['location']}[{var['offset']}]")
        
        return "\n".join(lines)
