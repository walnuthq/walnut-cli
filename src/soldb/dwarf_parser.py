"""
DWARF Debug Information Parser for EVM

Parses DWARF debug information from ELF files generated by evm-dwarf
to provide rich debugging capabilities.
"""

import os
import struct
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from pathlib import Path

try:
    # Try to use pyelftools for DWARF parsing
    from elftools.elf.elffile import ELFFile
    from elftools.dwarf.descriptions import describe_form_class
    from elftools.dwarf.dwarf_expr import DWARFExprParser
    HAS_ELFTOOLS = True
except ImportError:
    HAS_ELFTOOLS = False
    print("Warning: pyelftools not installed. Install with: pip install pyelftools")


@dataclass
class DwarfFunction:
    """Represents a function in DWARF debug info."""
    name: str
    linkage_name: str
    low_pc: int
    high_pc: int
    file: int
    line: int
    

@dataclass
class DwarfVariable:
    """Represents a variable in DWARF debug info."""
    name: str
    type_name: str
    size: int
    location: Any  # DWARF location expression
    

@dataclass 
class DwarfLineEntry:
    """Represents a line table entry."""
    address: int
    file: str
    line: int
    column: int


class DwarfParser:
    """Parser for DWARF debug information from EVM debug ELF files."""
    
    def __init__(self, debug_elf_path: str):
        self.debug_elf_path = debug_elf_path
        self.functions: Dict[str, DwarfFunction] = {}
        self.variables: Dict[str, DwarfVariable] = {}
        self.line_table: List[DwarfLineEntry] = []
        self.types: Dict[int, Dict[str, Any]] = {}
        
        if HAS_ELFTOOLS:
            self._parse_dwarf()
        else:
            # Fallback to basic parsing from .zasm files
            self._parse_from_zasm()
    
    def _parse_dwarf(self):
        """Parse DWARF information using pyelftools."""
        with open(self.debug_elf_path, 'rb') as f:
            elffile = ELFFile(f)
            
            if not elffile.has_dwarf_info():
                print(f"Warning: {self.debug_elf_path} has no DWARF info")
                return
                
            dwarf = elffile.get_dwarf_info()
            
            # Parse compilation units
            for CU in dwarf.iter_CUs():
                # Parse DIEs (Debugging Information Entries)
                for DIE in CU.iter_DIEs():
                    self._process_die(DIE, CU)
                    
                # Parse line program
                lineprog = dwarf.line_program_for_CU(CU)
                if lineprog:
                    self._parse_line_program(lineprog)
    
    def _process_die(self, die, cu):
        """Process a single DIE (Debugging Information Entry)."""
        if die.tag == 'DW_TAG_subprogram':
            # Function
            name = die.attributes.get('DW_AT_name')
            linkage_name = die.attributes.get('DW_AT_linkage_name')
            low_pc = die.attributes.get('DW_AT_low_pc')
            high_pc = die.attributes.get('DW_AT_high_pc')
            file = die.attributes.get('DW_AT_decl_file')
            line = die.attributes.get('DW_AT_decl_line')
            
            if name:
                func = DwarfFunction(
                    name=name.value.decode() if isinstance(name.value, bytes) else str(name.value),
                    linkage_name=linkage_name.value.decode() if linkage_name and isinstance(linkage_name.value, bytes) else '',
                    low_pc=low_pc.value if low_pc else 0,
                    high_pc=high_pc.value if high_pc else 0,
                    file=file.value if file else 0,
                    line=line.value if line else 0
                )
                self.functions[func.name] = func
                
        elif die.tag == 'DW_TAG_base_type':
            # Type information
            name = die.attributes.get('DW_AT_name')
            size = die.attributes.get('DW_AT_byte_size')
            encoding = die.attributes.get('DW_AT_encoding')
            
            if name:
                self.types[die.offset] = {
                    'name': name.value.decode() if isinstance(name.value, bytes) else str(name.value),
                    'size': size.value if size else 0,
                    'encoding': encoding.value if encoding else 0
                }
    
    def _parse_line_program(self, lineprog):
        """Parse DWARF line number program."""
        # Get file names
        files = {}
        for entry in lineprog['file_entry']:
            files[entry.index] = entry.name.decode() if isinstance(entry.name, bytes) else entry.name
            
        # Process line program
        for entry in lineprog.get_entries():
            if entry.state:
                line_entry = DwarfLineEntry(
                    address=entry.state.address,
                    file=files.get(entry.state.file, ''),
                    line=entry.state.line,
                    column=entry.state.column
                )
                self.line_table.append(line_entry)
    
    def _parse_from_zasm(self):
        """Fallback parser using .zasm file if pyelftools not available."""
        # Try to find corresponding .zasm file
        zasm_path = self.debug_elf_path.replace('.debug.elf', '.zasm')
        if not os.path.exists(zasm_path):
            zasm_path = self.debug_elf_path.replace('.debug', '.zasm')
            
        if os.path.exists(zasm_path):
            with open(zasm_path, 'r') as f:
                content = f.read()
                
            current_pc = 0
            current_func = None
            
            for line in content.split('\n'):
                line = line.strip()
                
                # Function labels
                if line.endswith(':') and not line.startswith('.'):
                    func_name = line[:-1]
                    current_func = DwarfFunction(
                        name=func_name,
                        linkage_name=func_name,
                        low_pc=current_pc,
                        high_pc=current_pc,  # Will update
                        file=1,
                        line=1
                    )
                    self.functions[func_name] = current_func
                    
                # Source locations
                elif line.startswith('.loc'):
                    parts = line.split()
                    if len(parts) >= 3:
                        file_id = int(parts[1])
                        line_num = int(parts[2])
                        
                        entry = DwarfLineEntry(
                            address=current_pc,
                            file=f"file_{file_id}",
                            line=line_num,
                            column=0
                        )
                        self.line_table.append(entry)
                        
                # Update PC for opcodes
                elif any(line.startswith(op) for op in ['PUSH', 'DUP', 'SWAP', 'JUMP', 'STOP']):
                    if current_func:
                        current_func.high_pc = current_pc
                        
                    # Estimate PC increment
                    if line.startswith('PUSH'):
                        if 'PUSH0' in line:
                            current_pc += 1
                        else:
                            # Extract number from PUSH1, PUSH2, etc
                            try:
                                push_num = int(''.join(filter(str.isdigit, line.split()[0])))
                                current_pc += 1 + push_num
                            except:
                                current_pc += 1
                    else:
                        current_pc += 1
    
    def get_source_location(self, pc: int) -> Optional[Tuple[str, int]]:
        """Get source file and line for a given PC."""
        # Find the closest line entry
        best_entry = None
        for entry in self.line_table:
            if entry.address <= pc:
                if not best_entry or entry.address > best_entry.address:
                    best_entry = entry
                    
        if best_entry:
            return (best_entry.file, best_entry.line)
        return None
        
    def get_function_at_pc(self, pc: int) -> Optional[DwarfFunction]:
        """Get function containing the given PC."""
        for func in self.functions.values():
            if func.low_pc <= pc <= func.high_pc:
                return func
        return None
        
    def get_backtrace_info(self, pc_list: List[int]) -> List[Dict[str, Any]]:
        """Get backtrace information for a list of PCs."""
        backtrace = []
        
        for pc in pc_list:
            func = self.get_function_at_pc(pc)
            source = self.get_source_location(pc)
            
            frame = {
                'pc': pc,
                'function': func.name if func else '<unknown>',
                'file': source[0] if source else '<unknown>',
                'line': source[1] if source else 0
            }
            backtrace.append(frame)
            
        return backtrace


def load_dwarf_info(debug_elf_path: str) -> Optional[DwarfParser]:
    """Load DWARF debug information from an ELF file."""
    if not os.path.exists(debug_elf_path):
        print(f"Debug ELF file not found: {debug_elf_path}")
        return None
        
    try:
        return DwarfParser(debug_elf_path)
    except Exception as e:
        print(f"Error loading DWARF info: {e}")
        return None
